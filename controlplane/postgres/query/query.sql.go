// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package query

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChunk = `-- name: CreateChunk :one
/*
 * CHUNKS
 */

INSERT INTO chunks
    (id, name, description, tags)
VALUES
    ($1, $2, $3, $4)
RETURNING id, name, description, tags, created_at, updated_at
`

type CreateChunkParams struct {
	ID          string
	Name        string
	Description string
	Tags        []string
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) (Chunk, error) {
	row := q.db.QueryRow(ctx, createChunk,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Tags,
	)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFlavor = `-- name: CreateFlavor :one
/*
 * FLAVORS
 */

INSERT INTO flavors
    (id, chunk_id, name, base_image_url, checkpoint_image_url)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id, chunk_id, name, base_image_url, checkpoint_image_url, created_at, updated_at
`

type CreateFlavorParams struct {
	ID                 string
	ChunkID            string
	Name               string
	BaseImageUrl       string
	CheckpointImageUrl string
}

func (q *Queries) CreateFlavor(ctx context.Context, arg CreateFlavorParams) (Flavor, error) {
	row := q.db.QueryRow(ctx, createFlavor,
		arg.ID,
		arg.ChunkID,
		arg.Name,
		arg.BaseImageUrl,
		arg.CheckpointImageUrl,
	)
	var i Flavor
	err := row.Scan(
		&i.ID,
		&i.ChunkID,
		&i.Name,
		&i.BaseImageUrl,
		&i.CheckpointImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInstance = `-- name: CreateInstance :exec
/*
 * INSTANCES
 */

INSERT INTO instances
    (id, flavor_id, node_id)
VALUES
    ($1, $2, $3)
`

type CreateInstanceParams struct {
	ID       string
	FlavorID string
	NodeID   string
}

func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) error {
	_, err := q.db.Exec(ctx, createInstance, arg.ID, arg.FlavorID, arg.NodeID)
	return err
}

const getChunkByID = `-- name: GetChunkByID :many
SELECT c.id, c.name, description, tags, c.created_at, c.updated_at, f.id, chunk_id, f.name, base_image_url, checkpoint_image_url, f.created_at, f.updated_at FROM chunks c
    JOIN flavors f ON f.chunk_id = c.id
WHERE c.id = $1
`

type GetChunkByIDRow struct {
	ID                 string
	Name               string
	Description        string
	Tags               []string
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
	ID_2               string
	ChunkID            string
	Name_2             string
	BaseImageUrl       string
	CheckpointImageUrl string
	CreatedAt_2        pgtype.Timestamptz
	UpdatedAt_2        pgtype.Timestamptz
}

func (q *Queries) GetChunkByID(ctx context.Context, id string) ([]GetChunkByIDRow, error) {
	rows, err := q.db.Query(ctx, getChunkByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChunkByIDRow
	for rows.Next() {
		var i GetChunkByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.ChunkID,
			&i.Name_2,
			&i.BaseImageUrl,
			&i.CheckpointImageUrl,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstance = `-- name: GetInstance :one
SELECT i.id, flavor_id, node_id, state, i.created_at, i.updated_at, f.id, chunk_id, f.name, base_image_url, checkpoint_image_url, f.created_at, f.updated_at, c.id, c.name, description, tags, c.created_at, c.updated_at, n.id, address, n.created_at FROM instances i
    JOIN flavors f ON i.flavor_id = f.id
    JOIN chunks c ON f.chunk_id = c.id
    JOIN nodes n ON i.node_id = n.id
WHERE i.id = $1
`

type GetInstanceRow struct {
	ID                 string
	FlavorID           string
	NodeID             string
	State              InstanceState
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
	ID_2               string
	ChunkID            string
	Name               string
	BaseImageUrl       string
	CheckpointImageUrl string
	CreatedAt_2        pgtype.Timestamptz
	UpdatedAt_2        pgtype.Timestamptz
	ID_3               string
	Name_2             string
	Description        string
	Tags               []string
	CreatedAt_3        pgtype.Timestamptz
	UpdatedAt_3        pgtype.Timestamptz
	ID_4               string
	Address            netip.Addr
	CreatedAt_4        pgtype.Timestamptz
}

func (q *Queries) GetInstance(ctx context.Context, id string) (GetInstanceRow, error) {
	row := q.db.QueryRow(ctx, getInstance, id)
	var i GetInstanceRow
	err := row.Scan(
		&i.ID,
		&i.FlavorID,
		&i.NodeID,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.ChunkID,
		&i.Name,
		&i.BaseImageUrl,
		&i.CheckpointImageUrl,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.ID_3,
		&i.Name_2,
		&i.Description,
		&i.Tags,
		&i.CreatedAt_3,
		&i.UpdatedAt_3,
		&i.ID_4,
		&i.Address,
		&i.CreatedAt_4,
	)
	return i, err
}

const updateChunk = `-- name: UpdateChunk :one
UPDATE chunks
SET
    name = $1,
    description = $2,
    tags = $3,
    updated_at = now()
WHERE id = $4
RETURNING id, name, description, tags, created_at, updated_at
`

type UpdateChunkParams struct {
	Name        string
	Description string
	Tags        []string
	ID          string
}

func (q *Queries) UpdateChunk(ctx context.Context, arg UpdateChunkParams) (Chunk, error) {
	row := q.db.QueryRow(ctx, updateChunk,
		arg.Name,
		arg.Description,
		arg.Tags,
		arg.ID,
	)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
