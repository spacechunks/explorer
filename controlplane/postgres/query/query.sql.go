// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package query

import (
	"context"
	"net/netip"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const allMinecraftVersions = `-- name: AllMinecraftVersions :many
/*
 * MINECRAFT VERSIONS
 */

SELECT version FROM minecraft_versions
`

func (q *Queries) AllMinecraftVersions(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, allMinecraftVersions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var version string
		if err := rows.Scan(&version); err != nil {
			return nil, err
		}
		items = append(items, version)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const chunkExists = `-- name: ChunkExists :one
SELECT EXISTS(
    SELECT 1 FROM chunks
    WHERE id = $1
)
`

func (q *Queries) ChunkExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, chunkExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const chunkOwnerByChunkID = `-- name: ChunkOwnerByChunkID :one
SELECT u.id, u.nickname, u.email, u.created_at, u.updated_at FROM users u
    LEFT JOIN chunks c ON c.owner_id = u.id
WHERE c.id = $1
`

func (q *Queries) ChunkOwnerByChunkID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, chunkOwnerByChunkID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const chunkOwnerByFlavorID = `-- name: ChunkOwnerByFlavorID :one
SELECT u.id, u.nickname, u.email, u.created_at, u.updated_at FROM users u
    JOIN flavors f ON f.id = $1
    JOIN chunks c ON c.id = f.chunk_id
    JOIN users ON u.id = c.owner_id
LIMIT 1
`

func (q *Queries) ChunkOwnerByFlavorID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, chunkOwnerByFlavorID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const chunkOwnerByFlavorVersionID = `-- name: ChunkOwnerByFlavorVersionID :one
SELECT u.id, u.nickname, u.email, u.created_at, u.updated_at FROM users u
    JOIN flavor_versions fv ON fv.id = $1
    JOIN flavors f ON f.id = fv.flavor_id
    JOIN chunks c ON c.id = f.chunk_id
    JOIN users ON u.id = c.owner_id
LIMIT 1
`

func (q *Queries) ChunkOwnerByFlavorVersionID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRow(ctx, chunkOwnerByFlavorVersionID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createChunk = `-- name: CreateChunk :exec
/*
 * CHUNKS
 */

INSERT INTO chunks
    (id, name, description, tags, owner_id, created_at, updated_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7)
`

type CreateChunkParams struct {
	ID          string
	Name        string
	Description string
	Tags        []string
	OwnerID     string
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) CreateChunk(ctx context.Context, arg CreateChunkParams) error {
	_, err := q.db.Exec(ctx, createChunk,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Tags,
		arg.OwnerID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createFlavor = `-- name: CreateFlavor :exec
/*
 * FLAVORS
 */

INSERT INTO flavors
    (id, chunk_id, name, created_at, updated_at)
VALUES
    ($1, $2, $3, $4, $5)
`

type CreateFlavorParams struct {
	ID        string
	ChunkID   string
	Name      string
	CreatedAt time.Time
	UpdatedAt time.Time
}

// TODO: insert multiple (aka :batchmany)
func (q *Queries) CreateFlavor(ctx context.Context, arg CreateFlavorParams) error {
	_, err := q.db.Exec(ctx, createFlavor,
		arg.ID,
		arg.ChunkID,
		arg.Name,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createFlavorVersion = `-- name: CreateFlavorVersion :exec
INSERT INTO flavor_versions
    (id, flavor_id, hash, change_hash, version, prev_version_id, minecraft_version, created_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateFlavorVersionParams struct {
	ID               string
	FlavorID         string
	Hash             string
	ChangeHash       string
	Version          string
	PrevVersionID    *string
	MinecraftVersion string
	CreatedAt        time.Time
}

func (q *Queries) CreateFlavorVersion(ctx context.Context, arg CreateFlavorVersionParams) error {
	_, err := q.db.Exec(ctx, createFlavorVersion,
		arg.ID,
		arg.FlavorID,
		arg.Hash,
		arg.ChangeHash,
		arg.Version,
		arg.PrevVersionID,
		arg.MinecraftVersion,
		arg.CreatedAt,
	)
	return err
}

const createInstance = `-- name: CreateInstance :exec
/*
 * INSTANCES
 */

INSERT INTO instances
    (id, chunk_id, flavor_version_id, node_id, state, owner_id, created_at, updated_at)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateInstanceParams struct {
	ID              string
	ChunkID         string
	FlavorVersionID string
	NodeID          string
	State           InstanceState
	OwnerID         string
	CreatedAt       time.Time
	UpdatedAt       time.Time
}

func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) error {
	_, err := q.db.Exec(ctx, createInstance,
		arg.ID,
		arg.ChunkID,
		arg.FlavorVersionID,
		arg.NodeID,
		arg.State,
		arg.OwnerID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users
    (id, nickname, email, created_at, updated_at)
VALUES
    ($1, $2, $3, $4, $5)
`

type CreateUserParams struct {
	ID        string
	Nickname  string
	Email     string
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.Nickname,
		arg.Email,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const flavorNameExists = `-- name: FlavorNameExists :one
SELECT EXISTS(
    SELECT 1 FROM flavors
    WHERE name = $1 AND chunk_id = $2
)
`

type FlavorNameExistsParams struct {
	Name    string
	ChunkID string
}

func (q *Queries) FlavorNameExists(ctx context.Context, arg FlavorNameExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, flavorNameExists, arg.Name, arg.ChunkID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const flavorVersionByID = `-- name: FlavorVersionByID :many
SELECT id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, v.created_at, presigned_url_expiry_date, presigned_url, minecraft_version, flavor_version_id, file_hash, file_path, f.created_at FROM flavor_versions v
    JOIN flavor_version_files f ON f.flavor_version_id = v.id
WHERE id = $1
`

type FlavorVersionByIDRow struct {
	ID                     string
	FlavorID               string
	Hash                   string
	ChangeHash             string
	BuildStatus            BuildStatus
	Version                string
	FilesUploaded          bool
	PrevVersionID          *string
	CreatedAt              time.Time
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	MinecraftVersion       string
	FlavorVersionID        string
	FileHash               string
	FilePath               string
	CreatedAt_2            time.Time
}

func (q *Queries) FlavorVersionByID(ctx context.Context, id string) ([]FlavorVersionByIDRow, error) {
	rows, err := q.db.Query(ctx, flavorVersionByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FlavorVersionByIDRow
	for rows.Next() {
		var i FlavorVersionByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.FlavorID,
			&i.Hash,
			&i.ChangeHash,
			&i.BuildStatus,
			&i.Version,
			&i.FilesUploaded,
			&i.PrevVersionID,
			&i.CreatedAt,
			&i.PresignedUrlExpiryDate,
			&i.PresignedUrl,
			&i.MinecraftVersion,
			&i.FlavorVersionID,
			&i.FileHash,
			&i.FilePath,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const flavorVersionExists = `-- name: FlavorVersionExists :one
SELECT EXISTS(
    SELECT 1 FROM flavor_versions
    WHERE version = $1 AND flavor_id = $2
)
`

type FlavorVersionExistsParams struct {
	Version  string
	FlavorID string
}

func (q *Queries) FlavorVersionExists(ctx context.Context, arg FlavorVersionExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, flavorVersionExists, arg.Version, arg.FlavorID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const flavorVersionFileHashes = `-- name: FlavorVersionFileHashes :many
SELECT flavor_version_id, file_hash, file_path, created_at FROM flavor_version_files WHERE flavor_version_id = $1
`

func (q *Queries) FlavorVersionFileHashes(ctx context.Context, flavorVersionID string) ([]FlavorVersionFile, error) {
	rows, err := q.db.Query(ctx, flavorVersionFileHashes, flavorVersionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FlavorVersionFile
	for rows.Next() {
		var i FlavorVersionFile
		if err := rows.Scan(
			&i.FlavorVersionID,
			&i.FileHash,
			&i.FilePath,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const flavorVersionHashByID = `-- name: FlavorVersionHashByID :one
SELECT hash FROM flavor_versions WHERE id = $1
`

func (q *Queries) FlavorVersionHashByID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRow(ctx, flavorVersionHashByID, id)
	var hash string
	err := row.Scan(&hash)
	return hash, err
}

const getChunkByID = `-- name: GetChunkByID :many
SELECT c.id, c.name, description, tags, c.created_at, c.updated_at, owner_id, thumbnail_hash, thumbnail_updated_at, f.id, chunk_id, f.name, f.created_at, f.updated_at, v.id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, v.created_at, presigned_url_expiry_date, presigned_url, minecraft_version, flavor_version_id, file_hash, file_path, vf.created_at, u.id, nickname, email, u.created_at, u.updated_at FROM chunks c
    LEFT JOIN flavors f ON f.chunk_id = c.id
    LEFT JOIN flavor_versions v ON v.flavor_id = f.id
    LEFT JOIN flavor_version_files vf ON vf.flavor_version_id = v.id
    LEFT JOIN users u ON u.id = c.owner_id
WHERE c.id = $1
`

type GetChunkByIDRow struct {
	ID                     string
	Name                   string
	Description            string
	Tags                   []string
	CreatedAt              time.Time
	UpdatedAt              time.Time
	OwnerID                string
	ThumbnailHash          pgtype.Text
	ThumbnailUpdatedAt     time.Time
	ID_2                   *string
	ChunkID                *string
	Name_2                 pgtype.Text
	CreatedAt_2            pgtype.Timestamptz
	UpdatedAt_2            pgtype.Timestamptz
	ID_3                   *string
	FlavorID               *string
	Hash                   pgtype.Text
	ChangeHash             pgtype.Text
	BuildStatus            NullBuildStatus
	Version                pgtype.Text
	FilesUploaded          pgtype.Bool
	PrevVersionID          *string
	CreatedAt_3            pgtype.Timestamptz
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	MinecraftVersion       pgtype.Text
	FlavorVersionID        *string
	FileHash               pgtype.Text
	FilePath               pgtype.Text
	CreatedAt_4            pgtype.Timestamptz
	ID_4                   *string
	Nickname               pgtype.Text
	Email                  pgtype.Text
	CreatedAt_5            pgtype.Timestamptz
	UpdatedAt_3            pgtype.Timestamptz
}

// TODO: read multiple
func (q *Queries) GetChunkByID(ctx context.Context, id string) ([]GetChunkByIDRow, error) {
	rows, err := q.db.Query(ctx, getChunkByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChunkByIDRow
	for rows.Next() {
		var i GetChunkByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.ThumbnailHash,
			&i.ThumbnailUpdatedAt,
			&i.ID_2,
			&i.ChunkID,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.ID_3,
			&i.FlavorID,
			&i.Hash,
			&i.ChangeHash,
			&i.BuildStatus,
			&i.Version,
			&i.FilesUploaded,
			&i.PrevVersionID,
			&i.CreatedAt_3,
			&i.PresignedUrlExpiryDate,
			&i.PresignedUrl,
			&i.MinecraftVersion,
			&i.FlavorVersionID,
			&i.FileHash,
			&i.FilePath,
			&i.CreatedAt_4,
			&i.ID_4,
			&i.Nickname,
			&i.Email,
			&i.CreatedAt_5,
			&i.UpdatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstance = `-- name: GetInstance :many
SELECT i.id, i.chunk_id, flavor_version_id, node_id, port, state, i.created_at, i.updated_at, i.owner_id, v.id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, v.created_at, presigned_url_expiry_date, presigned_url, minecraft_version, c.id, c.name, description, tags, c.created_at, c.updated_at, c.owner_id, thumbnail_hash, thumbnail_updated_at, f.id, f.chunk_id, f.name, f.created_at, f.updated_at, n.id, n.name, address, checkpoint_api_endpoint, n.created_at, u.id, nickname, email, u.created_at, u.updated_at FROM instances i
    JOIN flavor_versions v ON i.flavor_version_id = v.id
    JOIN chunks c ON i.chunk_id = c.id
    JOIN flavors f ON f.chunk_id = c.id
    JOIN nodes n ON i.node_id = n.id
    JOIN users u ON u.id = i.owner_id
WHERE i.id = $1
`

type GetInstanceRow struct {
	ID                     string
	ChunkID                string
	FlavorVersionID        string
	NodeID                 string
	Port                   *int32
	State                  InstanceState
	CreatedAt              time.Time
	UpdatedAt              time.Time
	OwnerID                string
	ID_2                   string
	FlavorID               string
	Hash                   string
	ChangeHash             string
	BuildStatus            BuildStatus
	Version                string
	FilesUploaded          bool
	PrevVersionID          *string
	CreatedAt_2            time.Time
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	MinecraftVersion       string
	ID_3                   string
	Name                   string
	Description            string
	Tags                   []string
	CreatedAt_3            time.Time
	UpdatedAt_2            time.Time
	OwnerID_2              string
	ThumbnailHash          pgtype.Text
	ThumbnailUpdatedAt     time.Time
	ID_4                   string
	ChunkID_2              string
	Name_2                 string
	CreatedAt_4            time.Time
	UpdatedAt_3            time.Time
	ID_5                   string
	Name_3                 string
	Address                netip.Addr
	CheckpointApiEndpoint  string
	CreatedAt_5            time.Time
	ID_6                   string
	Nickname               string
	Email                  string
	CreatedAt_6            time.Time
	UpdatedAt_4            time.Time
}

func (q *Queries) GetInstance(ctx context.Context, id string) ([]GetInstanceRow, error) {
	rows, err := q.db.Query(ctx, getInstance, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInstanceRow
	for rows.Next() {
		var i GetInstanceRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.FlavorVersionID,
			&i.NodeID,
			&i.Port,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.ID_2,
			&i.FlavorID,
			&i.Hash,
			&i.ChangeHash,
			&i.BuildStatus,
			&i.Version,
			&i.FilesUploaded,
			&i.PrevVersionID,
			&i.CreatedAt_2,
			&i.PresignedUrlExpiryDate,
			&i.PresignedUrl,
			&i.MinecraftVersion,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.CreatedAt_3,
			&i.UpdatedAt_2,
			&i.OwnerID_2,
			&i.ThumbnailHash,
			&i.ThumbnailUpdatedAt,
			&i.ID_4,
			&i.ChunkID_2,
			&i.Name_2,
			&i.CreatedAt_4,
			&i.UpdatedAt_3,
			&i.ID_5,
			&i.Name_3,
			&i.Address,
			&i.CheckpointApiEndpoint,
			&i.CreatedAt_5,
			&i.ID_6,
			&i.Nickname,
			&i.Email,
			&i.CreatedAt_6,
			&i.UpdatedAt_4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstancesByNodeID = `-- name: GetInstancesByNodeID :many
SELECT i.id, chunk_id, flavor_version_id, node_id, port, state, i.created_at, i.updated_at, i.owner_id, v.id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, v.created_at, presigned_url_expiry_date, presigned_url, minecraft_version, c.id, c.name, description, tags, c.created_at, c.updated_at, c.owner_id, thumbnail_hash, thumbnail_updated_at, n.id, n.name, address, checkpoint_api_endpoint, n.created_at, u.id, nickname, email, u.created_at, u.updated_at FROM instances i
    JOIN flavor_versions v ON i.flavor_version_id = v.id
    JOIN chunks c ON i.chunk_id = c.id
    JOIN nodes n ON i.node_id = n.id
    JOIN users u ON u.id = i.owner_id
WHERE i.node_id = $1
`

type GetInstancesByNodeIDRow struct {
	ID                     string
	ChunkID                string
	FlavorVersionID        string
	NodeID                 string
	Port                   *int32
	State                  InstanceState
	CreatedAt              time.Time
	UpdatedAt              time.Time
	OwnerID                string
	ID_2                   string
	FlavorID               string
	Hash                   string
	ChangeHash             string
	BuildStatus            BuildStatus
	Version                string
	FilesUploaded          bool
	PrevVersionID          *string
	CreatedAt_2            time.Time
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	MinecraftVersion       string
	ID_3                   string
	Name                   string
	Description            string
	Tags                   []string
	CreatedAt_3            time.Time
	UpdatedAt_2            time.Time
	OwnerID_2              string
	ThumbnailHash          pgtype.Text
	ThumbnailUpdatedAt     time.Time
	ID_4                   string
	Name_2                 string
	Address                netip.Addr
	CheckpointApiEndpoint  string
	CreatedAt_4            time.Time
	ID_5                   string
	Nickname               string
	Email                  string
	CreatedAt_5            time.Time
	UpdatedAt_3            time.Time
}

func (q *Queries) GetInstancesByNodeID(ctx context.Context, nodeID string) ([]GetInstancesByNodeIDRow, error) {
	rows, err := q.db.Query(ctx, getInstancesByNodeID, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInstancesByNodeIDRow
	for rows.Next() {
		var i GetInstancesByNodeIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.FlavorVersionID,
			&i.NodeID,
			&i.Port,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.ID_2,
			&i.FlavorID,
			&i.Hash,
			&i.ChangeHash,
			&i.BuildStatus,
			&i.Version,
			&i.FilesUploaded,
			&i.PrevVersionID,
			&i.CreatedAt_2,
			&i.PresignedUrlExpiryDate,
			&i.PresignedUrl,
			&i.MinecraftVersion,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.CreatedAt_3,
			&i.UpdatedAt_2,
			&i.OwnerID_2,
			&i.ThumbnailHash,
			&i.ThumbnailUpdatedAt,
			&i.ID_4,
			&i.Name_2,
			&i.Address,
			&i.CheckpointApiEndpoint,
			&i.CreatedAt_4,
			&i.ID_5,
			&i.Nickname,
			&i.Email,
			&i.CreatedAt_5,
			&i.UpdatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const latestFlavorVersionByFlavorID = `-- name: LatestFlavorVersionByFlavorID :one
SELECT id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, created_at, presigned_url_expiry_date, presigned_url, minecraft_version FROM flavor_versions WHERE flavor_id = $1
ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) LatestFlavorVersionByFlavorID(ctx context.Context, flavorID string) (FlavorVersion, error) {
	row := q.db.QueryRow(ctx, latestFlavorVersionByFlavorID, flavorID)
	var i FlavorVersion
	err := row.Scan(
		&i.ID,
		&i.FlavorID,
		&i.Hash,
		&i.ChangeHash,
		&i.BuildStatus,
		&i.Version,
		&i.FilesUploaded,
		&i.PrevVersionID,
		&i.CreatedAt,
		&i.PresignedUrlExpiryDate,
		&i.PresignedUrl,
		&i.MinecraftVersion,
	)
	return i, err
}

const listChunks = `-- name: ListChunks :many
SELECT c.id, c.name, description, tags, c.created_at, c.updated_at, owner_id, thumbnail_hash, thumbnail_updated_at, f.id, chunk_id, f.name, f.created_at, f.updated_at, v.id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, v.created_at, presigned_url_expiry_date, presigned_url, minecraft_version, flavor_version_id, file_hash, file_path, vf.created_at, u.id, nickname, email, u.created_at, u.updated_at FROM chunks c
    LEFT JOIN flavors f ON f.chunk_id = c.id
    LEFT JOIN flavor_versions v ON v.flavor_id = f.id
    LEFT JOIN flavor_version_files vf ON vf.flavor_version_id = v.id
    LEFT JOIN users u ON u.id = c.owner_id
`

type ListChunksRow struct {
	ID                     string
	Name                   string
	Description            string
	Tags                   []string
	CreatedAt              time.Time
	UpdatedAt              time.Time
	OwnerID                string
	ThumbnailHash          pgtype.Text
	ThumbnailUpdatedAt     time.Time
	ID_2                   *string
	ChunkID                *string
	Name_2                 pgtype.Text
	CreatedAt_2            pgtype.Timestamptz
	UpdatedAt_2            pgtype.Timestamptz
	ID_3                   *string
	FlavorID               *string
	Hash                   pgtype.Text
	ChangeHash             pgtype.Text
	BuildStatus            NullBuildStatus
	Version                pgtype.Text
	FilesUploaded          pgtype.Bool
	PrevVersionID          *string
	CreatedAt_3            pgtype.Timestamptz
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	MinecraftVersion       pgtype.Text
	FlavorVersionID        *string
	FileHash               pgtype.Text
	FilePath               pgtype.Text
	CreatedAt_4            pgtype.Timestamptz
	ID_4                   *string
	Nickname               pgtype.Text
	Email                  pgtype.Text
	CreatedAt_5            pgtype.Timestamptz
	UpdatedAt_3            pgtype.Timestamptz
}

func (q *Queries) ListChunks(ctx context.Context) ([]ListChunksRow, error) {
	rows, err := q.db.Query(ctx, listChunks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChunksRow
	for rows.Next() {
		var i ListChunksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.ThumbnailHash,
			&i.ThumbnailUpdatedAt,
			&i.ID_2,
			&i.ChunkID,
			&i.Name_2,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.ID_3,
			&i.FlavorID,
			&i.Hash,
			&i.ChangeHash,
			&i.BuildStatus,
			&i.Version,
			&i.FilesUploaded,
			&i.PrevVersionID,
			&i.CreatedAt_3,
			&i.PresignedUrlExpiryDate,
			&i.PresignedUrl,
			&i.MinecraftVersion,
			&i.FlavorVersionID,
			&i.FileHash,
			&i.FilePath,
			&i.CreatedAt_4,
			&i.ID_4,
			&i.Nickname,
			&i.Email,
			&i.CreatedAt_5,
			&i.UpdatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFlavorsByChunkID = `-- name: ListFlavorsByChunkID :many
SELECT f.id, chunk_id, name, f.created_at, updated_at, v.id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, v.created_at, presigned_url_expiry_date, presigned_url, minecraft_version, flavor_version_id, file_hash, file_path, vf.created_at FROM flavors f
    JOIN flavor_versions v ON v.flavor_id = f.id
    JOIN flavor_version_files vf ON vf.flavor_version_id = v.id
WHERE chunk_id = $1
`

type ListFlavorsByChunkIDRow struct {
	ID                     string
	ChunkID                string
	Name                   string
	CreatedAt              time.Time
	UpdatedAt              time.Time
	ID_2                   string
	FlavorID               string
	Hash                   string
	ChangeHash             string
	BuildStatus            BuildStatus
	Version                string
	FilesUploaded          bool
	PrevVersionID          *string
	CreatedAt_2            time.Time
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	MinecraftVersion       string
	FlavorVersionID        string
	FileHash               string
	FilePath               string
	CreatedAt_3            time.Time
}

func (q *Queries) ListFlavorsByChunkID(ctx context.Context, chunkID string) ([]ListFlavorsByChunkIDRow, error) {
	rows, err := q.db.Query(ctx, listFlavorsByChunkID, chunkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFlavorsByChunkIDRow
	for rows.Next() {
		var i ListFlavorsByChunkIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.FlavorID,
			&i.Hash,
			&i.ChangeHash,
			&i.BuildStatus,
			&i.Version,
			&i.FilesUploaded,
			&i.PrevVersionID,
			&i.CreatedAt_2,
			&i.PresignedUrlExpiryDate,
			&i.PresignedUrl,
			&i.MinecraftVersion,
			&i.FlavorVersionID,
			&i.FileHash,
			&i.FilePath,
			&i.CreatedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInstances = `-- name: ListInstances :many
SELECT i.id, i.chunk_id, flavor_version_id, node_id, port, state, i.created_at, i.updated_at, i.owner_id, v.id, flavor_id, hash, change_hash, build_status, version, files_uploaded, prev_version_id, v.created_at, presigned_url_expiry_date, presigned_url, minecraft_version, c.id, c.name, description, tags, c.created_at, c.updated_at, c.owner_id, thumbnail_hash, thumbnail_updated_at, f.id, f.chunk_id, f.name, f.created_at, f.updated_at, n.id, n.name, address, checkpoint_api_endpoint, n.created_at, u.id, nickname, email, u.created_at, u.updated_at FROM instances i
    JOIN flavor_versions v ON i.flavor_version_id = v.id
    JOIN chunks c ON i.chunk_id = c.id
    JOIN flavors f ON f.chunk_id = c.id
    JOIN nodes n ON i.node_id = n.id
    JOIN users u ON u.id = i.owner_id
`

type ListInstancesRow struct {
	ID                     string
	ChunkID                string
	FlavorVersionID        string
	NodeID                 string
	Port                   *int32
	State                  InstanceState
	CreatedAt              time.Time
	UpdatedAt              time.Time
	OwnerID                string
	ID_2                   string
	FlavorID               string
	Hash                   string
	ChangeHash             string
	BuildStatus            BuildStatus
	Version                string
	FilesUploaded          bool
	PrevVersionID          *string
	CreatedAt_2            time.Time
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	MinecraftVersion       string
	ID_3                   string
	Name                   string
	Description            string
	Tags                   []string
	CreatedAt_3            time.Time
	UpdatedAt_2            time.Time
	OwnerID_2              string
	ThumbnailHash          pgtype.Text
	ThumbnailUpdatedAt     time.Time
	ID_4                   string
	ChunkID_2              string
	Name_2                 string
	CreatedAt_4            time.Time
	UpdatedAt_3            time.Time
	ID_5                   string
	Name_3                 string
	Address                netip.Addr
	CheckpointApiEndpoint  string
	CreatedAt_5            time.Time
	ID_6                   string
	Nickname               string
	Email                  string
	CreatedAt_6            time.Time
	UpdatedAt_4            time.Time
}

func (q *Queries) ListInstances(ctx context.Context) ([]ListInstancesRow, error) {
	rows, err := q.db.Query(ctx, listInstances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInstancesRow
	for rows.Next() {
		var i ListInstancesRow
		if err := rows.Scan(
			&i.ID,
			&i.ChunkID,
			&i.FlavorVersionID,
			&i.NodeID,
			&i.Port,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerID,
			&i.ID_2,
			&i.FlavorID,
			&i.Hash,
			&i.ChangeHash,
			&i.BuildStatus,
			&i.Version,
			&i.FilesUploaded,
			&i.PrevVersionID,
			&i.CreatedAt_2,
			&i.PresignedUrlExpiryDate,
			&i.PresignedUrl,
			&i.MinecraftVersion,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.CreatedAt_3,
			&i.UpdatedAt_2,
			&i.OwnerID_2,
			&i.ThumbnailHash,
			&i.ThumbnailUpdatedAt,
			&i.ID_4,
			&i.ChunkID_2,
			&i.Name_2,
			&i.CreatedAt_4,
			&i.UpdatedAt_3,
			&i.ID_5,
			&i.Name_3,
			&i.Address,
			&i.CheckpointApiEndpoint,
			&i.CreatedAt_5,
			&i.ID_6,
			&i.Nickname,
			&i.Email,
			&i.CreatedAt_6,
			&i.UpdatedAt_4,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markFlavorVersionFilesUploaded = `-- name: MarkFlavorVersionFilesUploaded :exec
UPDATE flavor_versions SET files_uploaded = TRUE WHERE id = $1
`

func (q *Queries) MarkFlavorVersionFilesUploaded(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, markFlavorVersionFilesUploaded, id)
	return err
}

const minecraftVersionExists = `-- name: MinecraftVersionExists :one
SELECT EXISTS(
    SELECT 1 FROM minecraft_versions
    WHERE version = $1
)
`

func (q *Queries) MinecraftVersionExists(ctx context.Context, version string) (bool, error) {
	row := q.db.QueryRow(ctx, minecraftVersionExists, version)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const randomNode = `-- name: RandomNode :one
/*
 * NODES
 */

SELECT id, name, address, checkpoint_api_endpoint, created_at FROM nodes ORDER BY random() LIMIT 1
`

func (q *Queries) RandomNode(ctx context.Context) (Node, error) {
	row := q.db.QueryRow(ctx, randomNode)
	var i Node
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Address,
		&i.CheckpointApiEndpoint,
		&i.CreatedAt,
	)
	return i, err
}

const updateChunk = `-- name: UpdateChunk :exec
UPDATE chunks
SET
    name = $1,
    description = $2,
    tags = $3,
    updated_at = now()
WHERE id = $4
`

type UpdateChunkParams struct {
	Name        string
	Description string
	Tags        []string
	ID          string
}

func (q *Queries) UpdateChunk(ctx context.Context, arg UpdateChunkParams) error {
	_, err := q.db.Exec(ctx, updateChunk,
		arg.Name,
		arg.Description,
		arg.Tags,
		arg.ID,
	)
	return err
}

const updateChunkThumbnail = `-- name: UpdateChunkThumbnail :exec
UPDATE chunks SET
    thumbnail_hash = $1,
    thumbnail_updated_at = now()
WHERE id = $2
`

type UpdateChunkThumbnailParams struct {
	ThumbnailHash pgtype.Text
	ID            string
}

func (q *Queries) UpdateChunkThumbnail(ctx context.Context, arg UpdateChunkThumbnailParams) error {
	_, err := q.db.Exec(ctx, updateChunkThumbnail, arg.ThumbnailHash, arg.ID)
	return err
}

const updateFlavorVersionBuildStatus = `-- name: UpdateFlavorVersionBuildStatus :exec
UPDATE flavor_versions SET build_status = $1 WHERE id = $2
`

type UpdateFlavorVersionBuildStatusParams struct {
	BuildStatus BuildStatus
	ID          string
}

func (q *Queries) UpdateFlavorVersionBuildStatus(ctx context.Context, arg UpdateFlavorVersionBuildStatusParams) error {
	_, err := q.db.Exec(ctx, updateFlavorVersionBuildStatus, arg.BuildStatus, arg.ID)
	return err
}

const updateFlavorVersionPresignedURLData = `-- name: UpdateFlavorVersionPresignedURLData :exec
UPDATE flavor_versions SET
    presigned_url_expiry_date = $1,
    presigned_url = $2
WHERE id = $3
`

type UpdateFlavorVersionPresignedURLDataParams struct {
	PresignedUrlExpiryDate pgtype.Timestamptz
	PresignedUrl           pgtype.Text
	ID                     string
}

func (q *Queries) UpdateFlavorVersionPresignedURLData(ctx context.Context, arg UpdateFlavorVersionPresignedURLDataParams) error {
	_, err := q.db.Exec(ctx, updateFlavorVersionPresignedURLData, arg.PresignedUrlExpiryDate, arg.PresignedUrl, arg.ID)
	return err
}

const userByEmail = `-- name: UserByEmail :one
/*
 * USERS
 */

SELECT id, nickname, email, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) UserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, userByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Nickname,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
