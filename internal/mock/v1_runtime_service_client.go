// Code generated by mockery. DO NOT EDIT.

package mock

import (
	context "context"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"

	v1 "k8s.io/cri-api/pkg/apis/runtime/v1"
)

// MockV1RuntimeServiceClient is an autogenerated mock type for the RuntimeServiceClient type
type MockV1RuntimeServiceClient struct {
	mock.Mock
}

type MockV1RuntimeServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockV1RuntimeServiceClient) EXPECT() *MockV1RuntimeServiceClient_Expecter {
	return &MockV1RuntimeServiceClient_Expecter{mock: &_m.Mock}
}

// Attach provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) Attach(ctx context.Context, in *v1.AttachRequest, opts ...grpc.CallOption) (*v1.AttachResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Attach")
	}

	var r0 *v1.AttachResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.AttachRequest, ...grpc.CallOption) (*v1.AttachResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.AttachRequest, ...grpc.CallOption) *v1.AttachResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.AttachResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.AttachRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_Attach_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Attach'
type MockV1RuntimeServiceClient_Attach_Call struct {
	*mock.Call
}

// Attach is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.AttachRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) Attach(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_Attach_Call {
	return &MockV1RuntimeServiceClient_Attach_Call{Call: _e.mock.On("Attach",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_Attach_Call) Run(run func(ctx context.Context, in *v1.AttachRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_Attach_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.AttachRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_Attach_Call) Return(_a0 *v1.AttachResponse, _a1 error) *MockV1RuntimeServiceClient_Attach_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_Attach_Call) RunAndReturn(run func(context.Context, *v1.AttachRequest, ...grpc.CallOption) (*v1.AttachResponse, error)) *MockV1RuntimeServiceClient_Attach_Call {
	_c.Call.Return(run)
	return _c
}

// CheckpointContainer provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) CheckpointContainer(ctx context.Context, in *v1.CheckpointContainerRequest, opts ...grpc.CallOption) (*v1.CheckpointContainerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CheckpointContainer")
	}

	var r0 *v1.CheckpointContainerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.CheckpointContainerRequest, ...grpc.CallOption) (*v1.CheckpointContainerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.CheckpointContainerRequest, ...grpc.CallOption) *v1.CheckpointContainerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.CheckpointContainerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.CheckpointContainerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_CheckpointContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckpointContainer'
type MockV1RuntimeServiceClient_CheckpointContainer_Call struct {
	*mock.Call
}

// CheckpointContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.CheckpointContainerRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) CheckpointContainer(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_CheckpointContainer_Call {
	return &MockV1RuntimeServiceClient_CheckpointContainer_Call{Call: _e.mock.On("CheckpointContainer",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_CheckpointContainer_Call) Run(run func(ctx context.Context, in *v1.CheckpointContainerRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_CheckpointContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.CheckpointContainerRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_CheckpointContainer_Call) Return(_a0 *v1.CheckpointContainerResponse, _a1 error) *MockV1RuntimeServiceClient_CheckpointContainer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_CheckpointContainer_Call) RunAndReturn(run func(context.Context, *v1.CheckpointContainerRequest, ...grpc.CallOption) (*v1.CheckpointContainerResponse, error)) *MockV1RuntimeServiceClient_CheckpointContainer_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerStats provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ContainerStats(ctx context.Context, in *v1.ContainerStatsRequest, opts ...grpc.CallOption) (*v1.ContainerStatsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ContainerStats")
	}

	var r0 *v1.ContainerStatsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ContainerStatsRequest, ...grpc.CallOption) (*v1.ContainerStatsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ContainerStatsRequest, ...grpc.CallOption) *v1.ContainerStatsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ContainerStatsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ContainerStatsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ContainerStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerStats'
type MockV1RuntimeServiceClient_ContainerStats_Call struct {
	*mock.Call
}

// ContainerStats is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ContainerStatsRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ContainerStats(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ContainerStats_Call {
	return &MockV1RuntimeServiceClient_ContainerStats_Call{Call: _e.mock.On("ContainerStats",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ContainerStats_Call) Run(run func(ctx context.Context, in *v1.ContainerStatsRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ContainerStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ContainerStatsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ContainerStats_Call) Return(_a0 *v1.ContainerStatsResponse, _a1 error) *MockV1RuntimeServiceClient_ContainerStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ContainerStats_Call) RunAndReturn(run func(context.Context, *v1.ContainerStatsRequest, ...grpc.CallOption) (*v1.ContainerStatsResponse, error)) *MockV1RuntimeServiceClient_ContainerStats_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerStatus provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ContainerStatus(ctx context.Context, in *v1.ContainerStatusRequest, opts ...grpc.CallOption) (*v1.ContainerStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ContainerStatus")
	}

	var r0 *v1.ContainerStatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ContainerStatusRequest, ...grpc.CallOption) (*v1.ContainerStatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ContainerStatusRequest, ...grpc.CallOption) *v1.ContainerStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ContainerStatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ContainerStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ContainerStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerStatus'
type MockV1RuntimeServiceClient_ContainerStatus_Call struct {
	*mock.Call
}

// ContainerStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ContainerStatusRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ContainerStatus(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ContainerStatus_Call {
	return &MockV1RuntimeServiceClient_ContainerStatus_Call{Call: _e.mock.On("ContainerStatus",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ContainerStatus_Call) Run(run func(ctx context.Context, in *v1.ContainerStatusRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ContainerStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ContainerStatusRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ContainerStatus_Call) Return(_a0 *v1.ContainerStatusResponse, _a1 error) *MockV1RuntimeServiceClient_ContainerStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ContainerStatus_Call) RunAndReturn(run func(context.Context, *v1.ContainerStatusRequest, ...grpc.CallOption) (*v1.ContainerStatusResponse, error)) *MockV1RuntimeServiceClient_ContainerStatus_Call {
	_c.Call.Return(run)
	return _c
}

// CreateContainer provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) CreateContainer(ctx context.Context, in *v1.CreateContainerRequest, opts ...grpc.CallOption) (*v1.CreateContainerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateContainer")
	}

	var r0 *v1.CreateContainerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.CreateContainerRequest, ...grpc.CallOption) (*v1.CreateContainerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.CreateContainerRequest, ...grpc.CallOption) *v1.CreateContainerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.CreateContainerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.CreateContainerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_CreateContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateContainer'
type MockV1RuntimeServiceClient_CreateContainer_Call struct {
	*mock.Call
}

// CreateContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.CreateContainerRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) CreateContainer(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_CreateContainer_Call {
	return &MockV1RuntimeServiceClient_CreateContainer_Call{Call: _e.mock.On("CreateContainer",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_CreateContainer_Call) Run(run func(ctx context.Context, in *v1.CreateContainerRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_CreateContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.CreateContainerRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_CreateContainer_Call) Return(_a0 *v1.CreateContainerResponse, _a1 error) *MockV1RuntimeServiceClient_CreateContainer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_CreateContainer_Call) RunAndReturn(run func(context.Context, *v1.CreateContainerRequest, ...grpc.CallOption) (*v1.CreateContainerResponse, error)) *MockV1RuntimeServiceClient_CreateContainer_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) Exec(ctx context.Context, in *v1.ExecRequest, opts ...grpc.CallOption) (*v1.ExecResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 *v1.ExecResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ExecRequest, ...grpc.CallOption) (*v1.ExecResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ExecRequest, ...grpc.CallOption) *v1.ExecResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ExecResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ExecRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockV1RuntimeServiceClient_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ExecRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) Exec(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_Exec_Call {
	return &MockV1RuntimeServiceClient_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_Exec_Call) Run(run func(ctx context.Context, in *v1.ExecRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ExecRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_Exec_Call) Return(_a0 *v1.ExecResponse, _a1 error) *MockV1RuntimeServiceClient_Exec_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_Exec_Call) RunAndReturn(run func(context.Context, *v1.ExecRequest, ...grpc.CallOption) (*v1.ExecResponse, error)) *MockV1RuntimeServiceClient_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// ExecSync provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ExecSync(ctx context.Context, in *v1.ExecSyncRequest, opts ...grpc.CallOption) (*v1.ExecSyncResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExecSync")
	}

	var r0 *v1.ExecSyncResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ExecSyncRequest, ...grpc.CallOption) (*v1.ExecSyncResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ExecSyncRequest, ...grpc.CallOption) *v1.ExecSyncResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ExecSyncResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ExecSyncRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ExecSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecSync'
type MockV1RuntimeServiceClient_ExecSync_Call struct {
	*mock.Call
}

// ExecSync is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ExecSyncRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ExecSync(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ExecSync_Call {
	return &MockV1RuntimeServiceClient_ExecSync_Call{Call: _e.mock.On("ExecSync",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ExecSync_Call) Run(run func(ctx context.Context, in *v1.ExecSyncRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ExecSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ExecSyncRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ExecSync_Call) Return(_a0 *v1.ExecSyncResponse, _a1 error) *MockV1RuntimeServiceClient_ExecSync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ExecSync_Call) RunAndReturn(run func(context.Context, *v1.ExecSyncRequest, ...grpc.CallOption) (*v1.ExecSyncResponse, error)) *MockV1RuntimeServiceClient_ExecSync_Call {
	_c.Call.Return(run)
	return _c
}

// GetContainerEvents provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) GetContainerEvents(ctx context.Context, in *v1.GetEventsRequest, opts ...grpc.CallOption) (v1.RuntimeService_GetContainerEventsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetContainerEvents")
	}

	var r0 v1.RuntimeService_GetContainerEventsClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.GetEventsRequest, ...grpc.CallOption) (v1.RuntimeService_GetContainerEventsClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.GetEventsRequest, ...grpc.CallOption) v1.RuntimeService_GetContainerEventsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1.RuntimeService_GetContainerEventsClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.GetEventsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_GetContainerEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContainerEvents'
type MockV1RuntimeServiceClient_GetContainerEvents_Call struct {
	*mock.Call
}

// GetContainerEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.GetEventsRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) GetContainerEvents(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_GetContainerEvents_Call {
	return &MockV1RuntimeServiceClient_GetContainerEvents_Call{Call: _e.mock.On("GetContainerEvents",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_GetContainerEvents_Call) Run(run func(ctx context.Context, in *v1.GetEventsRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_GetContainerEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.GetEventsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_GetContainerEvents_Call) Return(_a0 v1.RuntimeService_GetContainerEventsClient, _a1 error) *MockV1RuntimeServiceClient_GetContainerEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_GetContainerEvents_Call) RunAndReturn(run func(context.Context, *v1.GetEventsRequest, ...grpc.CallOption) (v1.RuntimeService_GetContainerEventsClient, error)) *MockV1RuntimeServiceClient_GetContainerEvents_Call {
	_c.Call.Return(run)
	return _c
}

// ListContainerStats provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ListContainerStats(ctx context.Context, in *v1.ListContainerStatsRequest, opts ...grpc.CallOption) (*v1.ListContainerStatsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContainerStats")
	}

	var r0 *v1.ListContainerStatsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListContainerStatsRequest, ...grpc.CallOption) (*v1.ListContainerStatsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListContainerStatsRequest, ...grpc.CallOption) *v1.ListContainerStatsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ListContainerStatsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ListContainerStatsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ListContainerStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListContainerStats'
type MockV1RuntimeServiceClient_ListContainerStats_Call struct {
	*mock.Call
}

// ListContainerStats is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ListContainerStatsRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ListContainerStats(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ListContainerStats_Call {
	return &MockV1RuntimeServiceClient_ListContainerStats_Call{Call: _e.mock.On("ListContainerStats",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ListContainerStats_Call) Run(run func(ctx context.Context, in *v1.ListContainerStatsRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ListContainerStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ListContainerStatsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListContainerStats_Call) Return(_a0 *v1.ListContainerStatsResponse, _a1 error) *MockV1RuntimeServiceClient_ListContainerStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListContainerStats_Call) RunAndReturn(run func(context.Context, *v1.ListContainerStatsRequest, ...grpc.CallOption) (*v1.ListContainerStatsResponse, error)) *MockV1RuntimeServiceClient_ListContainerStats_Call {
	_c.Call.Return(run)
	return _c
}

// ListContainers provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ListContainers(ctx context.Context, in *v1.ListContainersRequest, opts ...grpc.CallOption) (*v1.ListContainersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListContainers")
	}

	var r0 *v1.ListContainersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListContainersRequest, ...grpc.CallOption) (*v1.ListContainersResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListContainersRequest, ...grpc.CallOption) *v1.ListContainersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ListContainersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ListContainersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ListContainers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListContainers'
type MockV1RuntimeServiceClient_ListContainers_Call struct {
	*mock.Call
}

// ListContainers is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ListContainersRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ListContainers(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ListContainers_Call {
	return &MockV1RuntimeServiceClient_ListContainers_Call{Call: _e.mock.On("ListContainers",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ListContainers_Call) Run(run func(ctx context.Context, in *v1.ListContainersRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ListContainers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ListContainersRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListContainers_Call) Return(_a0 *v1.ListContainersResponse, _a1 error) *MockV1RuntimeServiceClient_ListContainers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListContainers_Call) RunAndReturn(run func(context.Context, *v1.ListContainersRequest, ...grpc.CallOption) (*v1.ListContainersResponse, error)) *MockV1RuntimeServiceClient_ListContainers_Call {
	_c.Call.Return(run)
	return _c
}

// ListMetricDescriptors provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ListMetricDescriptors(ctx context.Context, in *v1.ListMetricDescriptorsRequest, opts ...grpc.CallOption) (*v1.ListMetricDescriptorsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMetricDescriptors")
	}

	var r0 *v1.ListMetricDescriptorsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListMetricDescriptorsRequest, ...grpc.CallOption) (*v1.ListMetricDescriptorsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListMetricDescriptorsRequest, ...grpc.CallOption) *v1.ListMetricDescriptorsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ListMetricDescriptorsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ListMetricDescriptorsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ListMetricDescriptors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMetricDescriptors'
type MockV1RuntimeServiceClient_ListMetricDescriptors_Call struct {
	*mock.Call
}

// ListMetricDescriptors is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ListMetricDescriptorsRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ListMetricDescriptors(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ListMetricDescriptors_Call {
	return &MockV1RuntimeServiceClient_ListMetricDescriptors_Call{Call: _e.mock.On("ListMetricDescriptors",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ListMetricDescriptors_Call) Run(run func(ctx context.Context, in *v1.ListMetricDescriptorsRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ListMetricDescriptors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ListMetricDescriptorsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListMetricDescriptors_Call) Return(_a0 *v1.ListMetricDescriptorsResponse, _a1 error) *MockV1RuntimeServiceClient_ListMetricDescriptors_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListMetricDescriptors_Call) RunAndReturn(run func(context.Context, *v1.ListMetricDescriptorsRequest, ...grpc.CallOption) (*v1.ListMetricDescriptorsResponse, error)) *MockV1RuntimeServiceClient_ListMetricDescriptors_Call {
	_c.Call.Return(run)
	return _c
}

// ListPodSandbox provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ListPodSandbox(ctx context.Context, in *v1.ListPodSandboxRequest, opts ...grpc.CallOption) (*v1.ListPodSandboxResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPodSandbox")
	}

	var r0 *v1.ListPodSandboxResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListPodSandboxRequest, ...grpc.CallOption) (*v1.ListPodSandboxResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListPodSandboxRequest, ...grpc.CallOption) *v1.ListPodSandboxResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ListPodSandboxResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ListPodSandboxRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ListPodSandbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPodSandbox'
type MockV1RuntimeServiceClient_ListPodSandbox_Call struct {
	*mock.Call
}

// ListPodSandbox is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ListPodSandboxRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ListPodSandbox(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ListPodSandbox_Call {
	return &MockV1RuntimeServiceClient_ListPodSandbox_Call{Call: _e.mock.On("ListPodSandbox",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ListPodSandbox_Call) Run(run func(ctx context.Context, in *v1.ListPodSandboxRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ListPodSandbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ListPodSandboxRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListPodSandbox_Call) Return(_a0 *v1.ListPodSandboxResponse, _a1 error) *MockV1RuntimeServiceClient_ListPodSandbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListPodSandbox_Call) RunAndReturn(run func(context.Context, *v1.ListPodSandboxRequest, ...grpc.CallOption) (*v1.ListPodSandboxResponse, error)) *MockV1RuntimeServiceClient_ListPodSandbox_Call {
	_c.Call.Return(run)
	return _c
}

// ListPodSandboxMetrics provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ListPodSandboxMetrics(ctx context.Context, in *v1.ListPodSandboxMetricsRequest, opts ...grpc.CallOption) (*v1.ListPodSandboxMetricsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPodSandboxMetrics")
	}

	var r0 *v1.ListPodSandboxMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListPodSandboxMetricsRequest, ...grpc.CallOption) (*v1.ListPodSandboxMetricsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListPodSandboxMetricsRequest, ...grpc.CallOption) *v1.ListPodSandboxMetricsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ListPodSandboxMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ListPodSandboxMetricsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPodSandboxMetrics'
type MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call struct {
	*mock.Call
}

// ListPodSandboxMetrics is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ListPodSandboxMetricsRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ListPodSandboxMetrics(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call {
	return &MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call{Call: _e.mock.On("ListPodSandboxMetrics",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call) Run(run func(ctx context.Context, in *v1.ListPodSandboxMetricsRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ListPodSandboxMetricsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call) Return(_a0 *v1.ListPodSandboxMetricsResponse, _a1 error) *MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call) RunAndReturn(run func(context.Context, *v1.ListPodSandboxMetricsRequest, ...grpc.CallOption) (*v1.ListPodSandboxMetricsResponse, error)) *MockV1RuntimeServiceClient_ListPodSandboxMetrics_Call {
	_c.Call.Return(run)
	return _c
}

// ListPodSandboxStats provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ListPodSandboxStats(ctx context.Context, in *v1.ListPodSandboxStatsRequest, opts ...grpc.CallOption) (*v1.ListPodSandboxStatsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPodSandboxStats")
	}

	var r0 *v1.ListPodSandboxStatsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListPodSandboxStatsRequest, ...grpc.CallOption) (*v1.ListPodSandboxStatsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ListPodSandboxStatsRequest, ...grpc.CallOption) *v1.ListPodSandboxStatsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ListPodSandboxStatsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ListPodSandboxStatsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ListPodSandboxStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPodSandboxStats'
type MockV1RuntimeServiceClient_ListPodSandboxStats_Call struct {
	*mock.Call
}

// ListPodSandboxStats is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ListPodSandboxStatsRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ListPodSandboxStats(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ListPodSandboxStats_Call {
	return &MockV1RuntimeServiceClient_ListPodSandboxStats_Call{Call: _e.mock.On("ListPodSandboxStats",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ListPodSandboxStats_Call) Run(run func(ctx context.Context, in *v1.ListPodSandboxStatsRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ListPodSandboxStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ListPodSandboxStatsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListPodSandboxStats_Call) Return(_a0 *v1.ListPodSandboxStatsResponse, _a1 error) *MockV1RuntimeServiceClient_ListPodSandboxStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ListPodSandboxStats_Call) RunAndReturn(run func(context.Context, *v1.ListPodSandboxStatsRequest, ...grpc.CallOption) (*v1.ListPodSandboxStatsResponse, error)) *MockV1RuntimeServiceClient_ListPodSandboxStats_Call {
	_c.Call.Return(run)
	return _c
}

// PodSandboxStats provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) PodSandboxStats(ctx context.Context, in *v1.PodSandboxStatsRequest, opts ...grpc.CallOption) (*v1.PodSandboxStatsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PodSandboxStats")
	}

	var r0 *v1.PodSandboxStatsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.PodSandboxStatsRequest, ...grpc.CallOption) (*v1.PodSandboxStatsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.PodSandboxStatsRequest, ...grpc.CallOption) *v1.PodSandboxStatsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.PodSandboxStatsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.PodSandboxStatsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_PodSandboxStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PodSandboxStats'
type MockV1RuntimeServiceClient_PodSandboxStats_Call struct {
	*mock.Call
}

// PodSandboxStats is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.PodSandboxStatsRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) PodSandboxStats(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_PodSandboxStats_Call {
	return &MockV1RuntimeServiceClient_PodSandboxStats_Call{Call: _e.mock.On("PodSandboxStats",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_PodSandboxStats_Call) Run(run func(ctx context.Context, in *v1.PodSandboxStatsRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_PodSandboxStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.PodSandboxStatsRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_PodSandboxStats_Call) Return(_a0 *v1.PodSandboxStatsResponse, _a1 error) *MockV1RuntimeServiceClient_PodSandboxStats_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_PodSandboxStats_Call) RunAndReturn(run func(context.Context, *v1.PodSandboxStatsRequest, ...grpc.CallOption) (*v1.PodSandboxStatsResponse, error)) *MockV1RuntimeServiceClient_PodSandboxStats_Call {
	_c.Call.Return(run)
	return _c
}

// PodSandboxStatus provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) PodSandboxStatus(ctx context.Context, in *v1.PodSandboxStatusRequest, opts ...grpc.CallOption) (*v1.PodSandboxStatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PodSandboxStatus")
	}

	var r0 *v1.PodSandboxStatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.PodSandboxStatusRequest, ...grpc.CallOption) (*v1.PodSandboxStatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.PodSandboxStatusRequest, ...grpc.CallOption) *v1.PodSandboxStatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.PodSandboxStatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.PodSandboxStatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_PodSandboxStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PodSandboxStatus'
type MockV1RuntimeServiceClient_PodSandboxStatus_Call struct {
	*mock.Call
}

// PodSandboxStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.PodSandboxStatusRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) PodSandboxStatus(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_PodSandboxStatus_Call {
	return &MockV1RuntimeServiceClient_PodSandboxStatus_Call{Call: _e.mock.On("PodSandboxStatus",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_PodSandboxStatus_Call) Run(run func(ctx context.Context, in *v1.PodSandboxStatusRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_PodSandboxStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.PodSandboxStatusRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_PodSandboxStatus_Call) Return(_a0 *v1.PodSandboxStatusResponse, _a1 error) *MockV1RuntimeServiceClient_PodSandboxStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_PodSandboxStatus_Call) RunAndReturn(run func(context.Context, *v1.PodSandboxStatusRequest, ...grpc.CallOption) (*v1.PodSandboxStatusResponse, error)) *MockV1RuntimeServiceClient_PodSandboxStatus_Call {
	_c.Call.Return(run)
	return _c
}

// PortForward provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) PortForward(ctx context.Context, in *v1.PortForwardRequest, opts ...grpc.CallOption) (*v1.PortForwardResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PortForward")
	}

	var r0 *v1.PortForwardResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.PortForwardRequest, ...grpc.CallOption) (*v1.PortForwardResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.PortForwardRequest, ...grpc.CallOption) *v1.PortForwardResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.PortForwardResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.PortForwardRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_PortForward_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PortForward'
type MockV1RuntimeServiceClient_PortForward_Call struct {
	*mock.Call
}

// PortForward is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.PortForwardRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) PortForward(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_PortForward_Call {
	return &MockV1RuntimeServiceClient_PortForward_Call{Call: _e.mock.On("PortForward",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_PortForward_Call) Run(run func(ctx context.Context, in *v1.PortForwardRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_PortForward_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.PortForwardRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_PortForward_Call) Return(_a0 *v1.PortForwardResponse, _a1 error) *MockV1RuntimeServiceClient_PortForward_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_PortForward_Call) RunAndReturn(run func(context.Context, *v1.PortForwardRequest, ...grpc.CallOption) (*v1.PortForwardResponse, error)) *MockV1RuntimeServiceClient_PortForward_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveContainer provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) RemoveContainer(ctx context.Context, in *v1.RemoveContainerRequest, opts ...grpc.CallOption) (*v1.RemoveContainerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveContainer")
	}

	var r0 *v1.RemoveContainerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RemoveContainerRequest, ...grpc.CallOption) (*v1.RemoveContainerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RemoveContainerRequest, ...grpc.CallOption) *v1.RemoveContainerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.RemoveContainerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.RemoveContainerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_RemoveContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveContainer'
type MockV1RuntimeServiceClient_RemoveContainer_Call struct {
	*mock.Call
}

// RemoveContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.RemoveContainerRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) RemoveContainer(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_RemoveContainer_Call {
	return &MockV1RuntimeServiceClient_RemoveContainer_Call{Call: _e.mock.On("RemoveContainer",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_RemoveContainer_Call) Run(run func(ctx context.Context, in *v1.RemoveContainerRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_RemoveContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.RemoveContainerRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_RemoveContainer_Call) Return(_a0 *v1.RemoveContainerResponse, _a1 error) *MockV1RuntimeServiceClient_RemoveContainer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_RemoveContainer_Call) RunAndReturn(run func(context.Context, *v1.RemoveContainerRequest, ...grpc.CallOption) (*v1.RemoveContainerResponse, error)) *MockV1RuntimeServiceClient_RemoveContainer_Call {
	_c.Call.Return(run)
	return _c
}

// RemovePodSandbox provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) RemovePodSandbox(ctx context.Context, in *v1.RemovePodSandboxRequest, opts ...grpc.CallOption) (*v1.RemovePodSandboxResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemovePodSandbox")
	}

	var r0 *v1.RemovePodSandboxResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RemovePodSandboxRequest, ...grpc.CallOption) (*v1.RemovePodSandboxResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RemovePodSandboxRequest, ...grpc.CallOption) *v1.RemovePodSandboxResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.RemovePodSandboxResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.RemovePodSandboxRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_RemovePodSandbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemovePodSandbox'
type MockV1RuntimeServiceClient_RemovePodSandbox_Call struct {
	*mock.Call
}

// RemovePodSandbox is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.RemovePodSandboxRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) RemovePodSandbox(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_RemovePodSandbox_Call {
	return &MockV1RuntimeServiceClient_RemovePodSandbox_Call{Call: _e.mock.On("RemovePodSandbox",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_RemovePodSandbox_Call) Run(run func(ctx context.Context, in *v1.RemovePodSandboxRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_RemovePodSandbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.RemovePodSandboxRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_RemovePodSandbox_Call) Return(_a0 *v1.RemovePodSandboxResponse, _a1 error) *MockV1RuntimeServiceClient_RemovePodSandbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_RemovePodSandbox_Call) RunAndReturn(run func(context.Context, *v1.RemovePodSandboxRequest, ...grpc.CallOption) (*v1.RemovePodSandboxResponse, error)) *MockV1RuntimeServiceClient_RemovePodSandbox_Call {
	_c.Call.Return(run)
	return _c
}

// ReopenContainerLog provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) ReopenContainerLog(ctx context.Context, in *v1.ReopenContainerLogRequest, opts ...grpc.CallOption) (*v1.ReopenContainerLogResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReopenContainerLog")
	}

	var r0 *v1.ReopenContainerLogResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ReopenContainerLogRequest, ...grpc.CallOption) (*v1.ReopenContainerLogResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.ReopenContainerLogRequest, ...grpc.CallOption) *v1.ReopenContainerLogResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.ReopenContainerLogResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.ReopenContainerLogRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_ReopenContainerLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReopenContainerLog'
type MockV1RuntimeServiceClient_ReopenContainerLog_Call struct {
	*mock.Call
}

// ReopenContainerLog is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.ReopenContainerLogRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) ReopenContainerLog(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_ReopenContainerLog_Call {
	return &MockV1RuntimeServiceClient_ReopenContainerLog_Call{Call: _e.mock.On("ReopenContainerLog",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_ReopenContainerLog_Call) Run(run func(ctx context.Context, in *v1.ReopenContainerLogRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_ReopenContainerLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.ReopenContainerLogRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_ReopenContainerLog_Call) Return(_a0 *v1.ReopenContainerLogResponse, _a1 error) *MockV1RuntimeServiceClient_ReopenContainerLog_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_ReopenContainerLog_Call) RunAndReturn(run func(context.Context, *v1.ReopenContainerLogRequest, ...grpc.CallOption) (*v1.ReopenContainerLogResponse, error)) *MockV1RuntimeServiceClient_ReopenContainerLog_Call {
	_c.Call.Return(run)
	return _c
}

// RunPodSandbox provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) RunPodSandbox(ctx context.Context, in *v1.RunPodSandboxRequest, opts ...grpc.CallOption) (*v1.RunPodSandboxResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunPodSandbox")
	}

	var r0 *v1.RunPodSandboxResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RunPodSandboxRequest, ...grpc.CallOption) (*v1.RunPodSandboxResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RunPodSandboxRequest, ...grpc.CallOption) *v1.RunPodSandboxResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.RunPodSandboxResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.RunPodSandboxRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_RunPodSandbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunPodSandbox'
type MockV1RuntimeServiceClient_RunPodSandbox_Call struct {
	*mock.Call
}

// RunPodSandbox is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.RunPodSandboxRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) RunPodSandbox(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_RunPodSandbox_Call {
	return &MockV1RuntimeServiceClient_RunPodSandbox_Call{Call: _e.mock.On("RunPodSandbox",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_RunPodSandbox_Call) Run(run func(ctx context.Context, in *v1.RunPodSandboxRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_RunPodSandbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.RunPodSandboxRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_RunPodSandbox_Call) Return(_a0 *v1.RunPodSandboxResponse, _a1 error) *MockV1RuntimeServiceClient_RunPodSandbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_RunPodSandbox_Call) RunAndReturn(run func(context.Context, *v1.RunPodSandboxRequest, ...grpc.CallOption) (*v1.RunPodSandboxResponse, error)) *MockV1RuntimeServiceClient_RunPodSandbox_Call {
	_c.Call.Return(run)
	return _c
}

// RuntimeConfig provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) RuntimeConfig(ctx context.Context, in *v1.RuntimeConfigRequest, opts ...grpc.CallOption) (*v1.RuntimeConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RuntimeConfig")
	}

	var r0 *v1.RuntimeConfigResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RuntimeConfigRequest, ...grpc.CallOption) (*v1.RuntimeConfigResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.RuntimeConfigRequest, ...grpc.CallOption) *v1.RuntimeConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.RuntimeConfigResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.RuntimeConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_RuntimeConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RuntimeConfig'
type MockV1RuntimeServiceClient_RuntimeConfig_Call struct {
	*mock.Call
}

// RuntimeConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.RuntimeConfigRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) RuntimeConfig(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_RuntimeConfig_Call {
	return &MockV1RuntimeServiceClient_RuntimeConfig_Call{Call: _e.mock.On("RuntimeConfig",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_RuntimeConfig_Call) Run(run func(ctx context.Context, in *v1.RuntimeConfigRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_RuntimeConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.RuntimeConfigRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_RuntimeConfig_Call) Return(_a0 *v1.RuntimeConfigResponse, _a1 error) *MockV1RuntimeServiceClient_RuntimeConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_RuntimeConfig_Call) RunAndReturn(run func(context.Context, *v1.RuntimeConfigRequest, ...grpc.CallOption) (*v1.RuntimeConfigResponse, error)) *MockV1RuntimeServiceClient_RuntimeConfig_Call {
	_c.Call.Return(run)
	return _c
}

// StartContainer provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) StartContainer(ctx context.Context, in *v1.StartContainerRequest, opts ...grpc.CallOption) (*v1.StartContainerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartContainer")
	}

	var r0 *v1.StartContainerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StartContainerRequest, ...grpc.CallOption) (*v1.StartContainerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StartContainerRequest, ...grpc.CallOption) *v1.StartContainerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.StartContainerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.StartContainerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_StartContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartContainer'
type MockV1RuntimeServiceClient_StartContainer_Call struct {
	*mock.Call
}

// StartContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.StartContainerRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) StartContainer(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_StartContainer_Call {
	return &MockV1RuntimeServiceClient_StartContainer_Call{Call: _e.mock.On("StartContainer",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_StartContainer_Call) Run(run func(ctx context.Context, in *v1.StartContainerRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_StartContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.StartContainerRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_StartContainer_Call) Return(_a0 *v1.StartContainerResponse, _a1 error) *MockV1RuntimeServiceClient_StartContainer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_StartContainer_Call) RunAndReturn(run func(context.Context, *v1.StartContainerRequest, ...grpc.CallOption) (*v1.StartContainerResponse, error)) *MockV1RuntimeServiceClient_StartContainer_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) Status(ctx context.Context, in *v1.StatusRequest, opts ...grpc.CallOption) (*v1.StatusResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 *v1.StatusResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StatusRequest, ...grpc.CallOption) (*v1.StatusResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StatusRequest, ...grpc.CallOption) *v1.StatusResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.StatusResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.StatusRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type MockV1RuntimeServiceClient_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.StatusRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) Status(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_Status_Call {
	return &MockV1RuntimeServiceClient_Status_Call{Call: _e.mock.On("Status",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_Status_Call) Run(run func(ctx context.Context, in *v1.StatusRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.StatusRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_Status_Call) Return(_a0 *v1.StatusResponse, _a1 error) *MockV1RuntimeServiceClient_Status_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_Status_Call) RunAndReturn(run func(context.Context, *v1.StatusRequest, ...grpc.CallOption) (*v1.StatusResponse, error)) *MockV1RuntimeServiceClient_Status_Call {
	_c.Call.Return(run)
	return _c
}

// StopContainer provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) StopContainer(ctx context.Context, in *v1.StopContainerRequest, opts ...grpc.CallOption) (*v1.StopContainerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopContainer")
	}

	var r0 *v1.StopContainerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StopContainerRequest, ...grpc.CallOption) (*v1.StopContainerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StopContainerRequest, ...grpc.CallOption) *v1.StopContainerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.StopContainerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.StopContainerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_StopContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopContainer'
type MockV1RuntimeServiceClient_StopContainer_Call struct {
	*mock.Call
}

// StopContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.StopContainerRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) StopContainer(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_StopContainer_Call {
	return &MockV1RuntimeServiceClient_StopContainer_Call{Call: _e.mock.On("StopContainer",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_StopContainer_Call) Run(run func(ctx context.Context, in *v1.StopContainerRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_StopContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.StopContainerRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_StopContainer_Call) Return(_a0 *v1.StopContainerResponse, _a1 error) *MockV1RuntimeServiceClient_StopContainer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_StopContainer_Call) RunAndReturn(run func(context.Context, *v1.StopContainerRequest, ...grpc.CallOption) (*v1.StopContainerResponse, error)) *MockV1RuntimeServiceClient_StopContainer_Call {
	_c.Call.Return(run)
	return _c
}

// StopPodSandbox provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) StopPodSandbox(ctx context.Context, in *v1.StopPodSandboxRequest, opts ...grpc.CallOption) (*v1.StopPodSandboxResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StopPodSandbox")
	}

	var r0 *v1.StopPodSandboxResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StopPodSandboxRequest, ...grpc.CallOption) (*v1.StopPodSandboxResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.StopPodSandboxRequest, ...grpc.CallOption) *v1.StopPodSandboxResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.StopPodSandboxResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.StopPodSandboxRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_StopPodSandbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopPodSandbox'
type MockV1RuntimeServiceClient_StopPodSandbox_Call struct {
	*mock.Call
}

// StopPodSandbox is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.StopPodSandboxRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) StopPodSandbox(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_StopPodSandbox_Call {
	return &MockV1RuntimeServiceClient_StopPodSandbox_Call{Call: _e.mock.On("StopPodSandbox",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_StopPodSandbox_Call) Run(run func(ctx context.Context, in *v1.StopPodSandboxRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_StopPodSandbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.StopPodSandboxRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_StopPodSandbox_Call) Return(_a0 *v1.StopPodSandboxResponse, _a1 error) *MockV1RuntimeServiceClient_StopPodSandbox_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_StopPodSandbox_Call) RunAndReturn(run func(context.Context, *v1.StopPodSandboxRequest, ...grpc.CallOption) (*v1.StopPodSandboxResponse, error)) *MockV1RuntimeServiceClient_StopPodSandbox_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateContainerResources provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) UpdateContainerResources(ctx context.Context, in *v1.UpdateContainerResourcesRequest, opts ...grpc.CallOption) (*v1.UpdateContainerResourcesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateContainerResources")
	}

	var r0 *v1.UpdateContainerResourcesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.UpdateContainerResourcesRequest, ...grpc.CallOption) (*v1.UpdateContainerResourcesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.UpdateContainerResourcesRequest, ...grpc.CallOption) *v1.UpdateContainerResourcesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.UpdateContainerResourcesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.UpdateContainerResourcesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_UpdateContainerResources_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateContainerResources'
type MockV1RuntimeServiceClient_UpdateContainerResources_Call struct {
	*mock.Call
}

// UpdateContainerResources is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.UpdateContainerResourcesRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) UpdateContainerResources(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_UpdateContainerResources_Call {
	return &MockV1RuntimeServiceClient_UpdateContainerResources_Call{Call: _e.mock.On("UpdateContainerResources",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_UpdateContainerResources_Call) Run(run func(ctx context.Context, in *v1.UpdateContainerResourcesRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_UpdateContainerResources_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.UpdateContainerResourcesRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_UpdateContainerResources_Call) Return(_a0 *v1.UpdateContainerResourcesResponse, _a1 error) *MockV1RuntimeServiceClient_UpdateContainerResources_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_UpdateContainerResources_Call) RunAndReturn(run func(context.Context, *v1.UpdateContainerResourcesRequest, ...grpc.CallOption) (*v1.UpdateContainerResourcesResponse, error)) *MockV1RuntimeServiceClient_UpdateContainerResources_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRuntimeConfig provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) UpdateRuntimeConfig(ctx context.Context, in *v1.UpdateRuntimeConfigRequest, opts ...grpc.CallOption) (*v1.UpdateRuntimeConfigResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRuntimeConfig")
	}

	var r0 *v1.UpdateRuntimeConfigResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.UpdateRuntimeConfigRequest, ...grpc.CallOption) (*v1.UpdateRuntimeConfigResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.UpdateRuntimeConfigRequest, ...grpc.CallOption) *v1.UpdateRuntimeConfigResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.UpdateRuntimeConfigResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.UpdateRuntimeConfigRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRuntimeConfig'
type MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call struct {
	*mock.Call
}

// UpdateRuntimeConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.UpdateRuntimeConfigRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) UpdateRuntimeConfig(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call {
	return &MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call{Call: _e.mock.On("UpdateRuntimeConfig",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call) Run(run func(ctx context.Context, in *v1.UpdateRuntimeConfigRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.UpdateRuntimeConfigRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call) Return(_a0 *v1.UpdateRuntimeConfigResponse, _a1 error) *MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call) RunAndReturn(run func(context.Context, *v1.UpdateRuntimeConfigRequest, ...grpc.CallOption) (*v1.UpdateRuntimeConfigResponse, error)) *MockV1RuntimeServiceClient_UpdateRuntimeConfig_Call {
	_c.Call.Return(run)
	return _c
}

// Version provides a mock function with given fields: ctx, in, opts
func (_m *MockV1RuntimeServiceClient) Version(ctx context.Context, in *v1.VersionRequest, opts ...grpc.CallOption) (*v1.VersionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 *v1.VersionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1.VersionRequest, ...grpc.CallOption) (*v1.VersionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *v1.VersionRequest, ...grpc.CallOption) *v1.VersionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.VersionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *v1.VersionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockV1RuntimeServiceClient_Version_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Version'
type MockV1RuntimeServiceClient_Version_Call struct {
	*mock.Call
}

// Version is a helper method to define mock.On call
//   - ctx context.Context
//   - in *v1.VersionRequest
//   - opts ...grpc.CallOption
func (_e *MockV1RuntimeServiceClient_Expecter) Version(ctx interface{}, in interface{}, opts ...interface{}) *MockV1RuntimeServiceClient_Version_Call {
	return &MockV1RuntimeServiceClient_Version_Call{Call: _e.mock.On("Version",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *MockV1RuntimeServiceClient_Version_Call) Run(run func(ctx context.Context, in *v1.VersionRequest, opts ...grpc.CallOption)) *MockV1RuntimeServiceClient_Version_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*v1.VersionRequest), variadicArgs...)
	})
	return _c
}

func (_c *MockV1RuntimeServiceClient_Version_Call) Return(_a0 *v1.VersionResponse, _a1 error) *MockV1RuntimeServiceClient_Version_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockV1RuntimeServiceClient_Version_Call) RunAndReturn(run func(context.Context, *v1.VersionRequest, ...grpc.CallOption) (*v1.VersionResponse, error)) *MockV1RuntimeServiceClient_Version_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockV1RuntimeServiceClient creates a new instance of MockV1RuntimeServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockV1RuntimeServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockV1RuntimeServiceClient {
	mock := &MockV1RuntimeServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
